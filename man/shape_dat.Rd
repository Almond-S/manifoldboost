% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/shape_dat-class.R
\name{shape_dat}
\alias{shape_dat}
\alias{new_shape_dat}
\alias{as_shape_dat.default}
\title{Build a \code{shape_dat} object}
\usage{
new_shape_dat(formula, ...)

\method{as_shape_dat}{default}(x, formula, validate = TRUE)
}
\arguments{
\item{formula}{formula defining the structure of the 'shape'.}

\item{...}{optional variables passed to \code{data.frame()} or \code{list()}.}

\item{x}{optional \code{data.frame} or \code{list} with relevant data.}

\item{validate}{logical, should an additional validation of the constructed \code{shape_dat}
be performed (if any)? Defaults to TRUE. FALSE might speed up computation time.}
}
\value{
usually just \code{x} with an extra attribute \code{'formula'}, plus eventually
extra variables provided in the formula, but not in \code{x}.
}
\description{
\code{shape_dat()} constructs a data frame of shapes of class \code{shape_dat}.

\code{as_shape_dat.default()} converts a \code{data.frame} or \code{list} to an object of
class \code{shape_dat}. The assigned subclass depends on the structure of the \code{formula}
and \code{x} provided.
}
\examples{
library(manifoldboost)
library(cubelyr)
# generate toy shapes
arg <- 1:20 / 20
id <- 1:8
n_arg <- length(arg)
n_id <- length(id)
x <- (rep(id,each=n_arg)/5 + 1) * cos(arg * 2*pi) + 2*cos(arg * 4*pi)
y <- (rep(id,each=n_arg)/5 + 1) * sin(arg * 2*pi) + 2*sin(arg * 4*pi)

# set up data in very long format
dat_longlong <- data.frame(
  wert = c(x,y), 
  d = rep(c("x","y"), each = n_arg*n_id),
  time = rep(arg, 2*length(id)), 
  ID = rep(rep(id, each = n_arg), 2)
  )

dat_longlong <- as_shape_dat(dat_longlong, wert^d ~ time | ID)

dat_default_ <- as_shape_frame_default(dat_longlong, 
                                       value.dim.names = NULL)

# ... and in the default format
dat_long <- data.frame(
  x = x, 
  y = y, 
  arg = rep(arg, n_id),
  id = rep(id, each = n_arg)
)
dat_long <- as_shape_dat(dat_long, cbind(x,y) ~ arg | id)

dat_longlong_ <- as_shape_frame_long(dat_long)
dat_long_ <- as_shape_frame_default(dat_longlong)

# ... and convert it to a shape_col
dat_long_col <- as_shape_col(dat_long_)
formula(dat_long_col)
shape_names(dat_long_col)

# ... and shape_col back to dat_long
dat_long_ <- as_shape_frame(dat_long_col)
formula(dat_long_)
class(dat_long_)

# ... also as shape_cube (as it is regular)
shp <- as.tbl_cube(dat_longlong, met_name = "wert")
dat_cube <- as_shape_dat(formula = shp ~ wert^d ~ time | ID)
dat_cube_ <- as_shape_cube(dat_longlong)

# ... or at last as shape_list
shp_list <- split(dat_longlong[, -4], dat_longlong$ID)
dat_list <- as_shape_dat(formula = shp_list ~ wert^d ~ time)

# plot long shapes per dimension:id
opar <- par(mfrow = c(2, 2))
lapply( split( shp, interaction(shp$.dim, shp$.id), drop = FALSE )[1:4], function(x) 
  with(x, plot(.arg, .value, t = "b", main = paste("id", .id[1], "dim", .dim[1]))) )  
par(opar)

# convert to array in the format of R package shapes
ashp <- as.array(shp)
plot(x = 0, y = 0, col = "white", xlim = range(ashp[,1,]), ylim = range(ashp[,2,]))
apply(ashp, 3, lines, t = "l")

# .. and back, e.g., as wide shapes 
opar <- par(mfrow = c(3, 3))
lapply( split( as_shape_wide(ashp), as_shape_wide(ashp)$.id ), function(x) 
  with(x, plot(.value1, .value2, t = "b")) )  
par(opar)
library(manifoldboost)
library(cubelyr)
# generate toy shapes
arg <- 1:20 / 20
id <- 1:8
n_arg <- length(arg)
n_id <- length(id)
x <- (rep(id,each=n_arg)/5 + 1) * cos(arg * 2*pi) + 2*cos(arg * 4*pi)
y <- (rep(id,each=n_arg)/5 + 1) * sin(arg * 2*pi) + 2*sin(arg * 4*pi)

# set up data in very long format
dat_longlong <- data.frame(
  wert = c(x,y), 
  d = rep(c("x","y"), each = n_arg*n_id),
  time = rep(arg, 2*length(id)), 
  ID = rep(rep(id, each = n_arg), 2)
  )

dat_longlong <- as_shape_dat(dat_longlong, wert^d ~ time | ID)

dat_default_ <- as_shape_frame_default(dat_longlong, 
                                       value.dim.names = NULL)

# ... and in the default format
dat_long <- data.frame(
  x = x, 
  y = y, 
  arg = rep(arg, n_id),
  id = rep(id, each = n_arg)
)
dat_long <- as_shape_dat(dat_long, cbind(x,y) ~ arg | id)

dat_longlong_ <- as_shape_frame_long(dat_long)
dat_long_ <- as_shape_frame_default(dat_longlong)

# ... and convert it to a shape_col
dat_long_col <- as_shape_col(dat_long_)
formula(dat_long_col)
shape_names(dat_long_col)

# ... and shape_col back to dat_long
dat_long_ <- as_shape_frame(dat_long_col)
formula(dat_long_)
class(dat_long_)

# ... also as shape_cube (as it is regular)
shp <- as.tbl_cube(dat_longlong, met_name = "wert")
dat_cube <- as_shape_dat(formula = shp ~ wert^d ~ time | ID)
dat_cube_ <- as_shape_cube(dat_longlong)

# ... or at last as shape_list
shp_list <- split(dat_longlong[, -4], dat_longlong$ID)
dat_list <- as_shape_dat(formula = shp_list ~ wert^d ~ time)

# plot long shapes per dimension:id
opar <- par(mfrow = c(2, 2))
lapply( split( shp, interaction(shp$.dim, shp$.id), drop = FALSE )[1:4], function(x) 
  with(x, plot(.arg, .value, t = "b", main = paste("id", .id[1], "dim", .dim[1]))) )  
par(opar)

# convert to array in the format of R package shapes
ashp <- as.array(shp)
plot(x = 0, y = 0, col = "white", xlim = range(ashp[,1,]), ylim = range(ashp[,2,]))
apply(ashp, 3, lines, t = "l")

# .. and back, e.g., as wide shapes 
opar <- par(mfrow = c(3, 3))
lapply( split( as_shape_wide(ashp), as_shape_wide(ashp)$.id ), function(x) 
  with(x, plot(.value1, .value2, t = "b")) )  
par(opar)
}
\seealso{
\code{as_shape_frame_default}, \code{as_shape_cube_default}, \code{as_shape_col_default}, ...
}
